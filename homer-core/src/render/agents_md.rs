#![allow(clippy::cast_precision_loss)]

use std::collections::HashMap;
use std::fmt::Write;

use tracing::info;

use crate::config::HomerConfig;
use crate::store::HomerStore;
use crate::types::{AnalysisKind, HyperedgeKind, NodeKind};

use super::traits::Renderer;

#[derive(Debug)]
pub struct AgentsMdRenderer;

#[async_trait::async_trait]
impl Renderer for AgentsMdRenderer {
    fn name(&self) -> &'static str {
        "agents_md"
    }

    fn output_path(&self) -> &'static str {
        "AGENTS.md"
    }

    async fn render(
        &self,
        store: &dyn HomerStore,
        _config: &HomerConfig,
    ) -> crate::error::Result<String> {
        let mut out = String::with_capacity(4096);

        writeln!(out, "# AGENTS.md").unwrap();
        writeln!(out).unwrap();
        writeln!(
            out,
            "<!-- Generated by Homer. Sections between homer:preserve markers are kept on update. -->"
        )
        .unwrap();
        writeln!(out).unwrap();

        // Build & Test Commands
        render_build_commands(&mut out, store).await?;

        // Module Map
        render_module_map(&mut out, store).await?;

        // Change Patterns
        render_change_patterns(&mut out, store).await?;

        // Danger Zones
        render_danger_zones(&mut out, store).await?;

        // Conventions
        render_conventions(&mut out, store).await?;

        info!(bytes = out.len(), "AGENTS.md rendered");
        Ok(out)
    }
}

// ── Build & Test Commands ─────────────────────────────────────────

async fn render_build_commands(
    out: &mut String,
    store: &dyn HomerStore,
) -> crate::error::Result<()> {
    writeln!(out, "## Build & Test Commands").unwrap();
    writeln!(out).unwrap();

    // Look for root module with CI metadata
    let mod_filter = crate::types::NodeFilter {
        kind: Some(NodeKind::Module),
        ..Default::default()
    };
    let modules = store.find_nodes(&mod_filter).await?;

    let mut found_commands = false;

    for module in &modules {
        if let Some(ci) = module.metadata.get("ci_commands") {
            if let Some(obj) = ci.as_object() {
                for (source, commands) in obj {
                    if let Some(cmds) = commands.as_array() {
                        writeln!(out, "**{source}:**").unwrap();
                        for cmd in cmds {
                            if let Some(s) = cmd.as_str() {
                                writeln!(out, "- `{s}`").unwrap();
                            }
                        }
                        writeln!(out).unwrap();
                        found_commands = true;
                    }
                }
            }
        }
    }

    // Check for build systems detected by structure extraction
    if !found_commands {
        let mut has_cargo = false;
        let mut has_npm = false;
        let mut has_python = false;
        let mut has_go = false;

        for module in &modules {
            if let Some(systems) = module
                .metadata
                .get("build_systems")
                .and_then(|v| v.as_array())
            {
                for sys in systems {
                    if let Some(s) = sys.as_str() {
                        match s {
                            "cargo" => has_cargo = true,
                            "npm" => has_npm = true,
                            "python" => has_python = true,
                            "go" => has_go = true,
                            _ => {}
                        }
                    }
                }
            }
        }

        if has_cargo {
            writeln!(out, "```bash").unwrap();
            writeln!(out, "cargo build          # Build").unwrap();
            writeln!(out, "cargo test           # Test").unwrap();
            writeln!(out, "cargo clippy         # Lint").unwrap();
            writeln!(out, "```").unwrap();
            writeln!(out).unwrap();
        }
        if has_npm {
            writeln!(out, "```bash").unwrap();
            writeln!(out, "npm install          # Install").unwrap();
            writeln!(out, "npm test             # Test").unwrap();
            writeln!(out, "```").unwrap();
            writeln!(out).unwrap();
        }
        if has_python {
            writeln!(out, "```bash").unwrap();
            writeln!(out, "pip install -e .     # Install").unwrap();
            writeln!(out, "pytest               # Test").unwrap();
            writeln!(out, "```").unwrap();
            writeln!(out).unwrap();
        }
        if has_go {
            writeln!(out, "```bash").unwrap();
            writeln!(out, "go build ./...       # Build").unwrap();
            writeln!(out, "go test ./...        # Test").unwrap();
            writeln!(out, "```").unwrap();
            writeln!(out).unwrap();
        }

        if !has_cargo && !has_npm && !has_python && !has_go {
            writeln!(out, "*No build commands detected.*").unwrap();
            writeln!(out).unwrap();
        }
    }

    Ok(())
}

// ── Module Map ────────────────────────────────────────────────────

async fn render_module_map(out: &mut String, store: &dyn HomerStore) -> crate::error::Result<()> {
    writeln!(out, "## Module Map").unwrap();
    writeln!(out).unwrap();

    let mod_filter = crate::types::NodeFilter {
        kind: Some(NodeKind::Module),
        ..Default::default()
    };
    let modules = store.find_nodes(&mod_filter).await?;

    if modules.is_empty() {
        writeln!(out, "*No modules detected.*").unwrap();
        writeln!(out).unwrap();
        return Ok(());
    }

    // Count files per module using BelongsTo edges
    let belongs_to = store.get_edges_by_kind(HyperedgeKind::BelongsTo).await?;
    let mut module_file_counts: HashMap<String, u32> = HashMap::new();

    for edge in &belongs_to {
        let container = edge.members.iter().find(|m| m.role == "container");
        let member = edge.members.iter().find(|m| m.role == "member");
        if let (Some(container_m), Some(_member_m)) = (container, member) {
            // Find which module this container is
            if let Ok(Some(node)) = store.get_node(container_m.node_id).await {
                if node.kind == NodeKind::Module {
                    *module_file_counts.entry(node.name.clone()).or_default() += 1;
                }
            }
        }
    }

    // Get file counts with Function/Type definitions per module
    let fn_filter = crate::types::NodeFilter {
        kind: Some(NodeKind::Function),
        ..Default::default()
    };
    let functions = store.find_nodes(&fn_filter).await?;

    let type_filter = crate::types::NodeFilter {
        kind: Some(NodeKind::Type),
        ..Default::default()
    };
    let types = store.find_nodes(&type_filter).await?;

    // Group by directory
    let mut module_defs: HashMap<String, (u32, u32)> = HashMap::new(); // (functions, types)
    for func in &functions {
        if let Some(file) = func.metadata.get("file").and_then(|v| v.as_str()) {
            let dir = std::path::Path::new(file)
                .parent()
                .map_or(".", |p| p.to_str().unwrap_or("."));
            module_defs.entry(dir.to_string()).or_default().0 += 1;
        }
    }
    for typ in &types {
        if let Some(file) = typ.metadata.get("file").and_then(|v| v.as_str()) {
            let dir = std::path::Path::new(file)
                .parent()
                .map_or(".", |p| p.to_str().unwrap_or("."));
            module_defs.entry(dir.to_string()).or_default().1 += 1;
        }
    }

    writeln!(out, "| Module | Files | Functions | Types |").unwrap();
    writeln!(out, "|--------|------:|----------:|------:|").unwrap();

    let mut sorted_modules: Vec<_> = modules.iter().collect();
    sorted_modules.sort_by_key(|m| &m.name);

    for module in &sorted_modules {
        let files = module_file_counts.get(&module.name).copied().unwrap_or(0);
        let (fns, tps) = module_defs.get(&module.name).copied().unwrap_or((0, 0));
        writeln!(out, "| `{}` | {} | {} | {} |", module.name, files, fns, tps).unwrap();
    }
    writeln!(out).unwrap();

    Ok(())
}

// ── Change Patterns ───────────────────────────────────────────────

async fn render_change_patterns(
    out: &mut String,
    store: &dyn HomerStore,
) -> crate::error::Result<()> {
    writeln!(out, "## Change Patterns").unwrap();
    writeln!(out).unwrap();

    let freq_results = store
        .get_analyses_by_kind(AnalysisKind::ChangeFrequency)
        .await?;

    if freq_results.is_empty() {
        writeln!(out, "*No change data available.*").unwrap();
        writeln!(out).unwrap();
        return Ok(());
    }

    // Collect (node_id, total) then resolve names
    let file_freqs: Vec<_> = freq_results
        .iter()
        .filter_map(|r| {
            let total = r.data.get("total")?.as_u64()?;
            Some((r.node_id, total))
        })
        .collect();

    let mut named_freqs = Vec::new();
    for (node_id, total) in &file_freqs {
        let name = store
            .get_node(*node_id)
            .await?
            .map_or_else(|| format!("node:{}", node_id.0), |n| n.name);
        named_freqs.push((name, *total));
    }
    named_freqs.sort_by(|a, b| b.1.cmp(&a.1));

    writeln!(out, "**Most frequently changed files:**").unwrap();
    writeln!(out).unwrap();
    writeln!(out, "| File | Changes |").unwrap();
    writeln!(out, "|------|--------:|").unwrap();

    for (name, total) in named_freqs.iter().take(10) {
        writeln!(out, "| `{name}` | {total} |").unwrap();
    }
    writeln!(out).unwrap();

    // Show co-change pairs
    let mut co_changes: Vec<(String, String, f64)> = Vec::new();
    for result in &freq_results {
        if let Some(partners) = result
            .data
            .get("co_change_partners")
            .and_then(|v| v.as_array())
        {
            let source_name = store
                .get_node(result.node_id)
                .await?
                .map_or_else(|| "?".to_string(), |n| n.name);
            for partner in partners.iter().take(3) {
                let partner_name = partner.get("file").and_then(|v| v.as_str()).unwrap_or("?");
                let confidence = partner
                    .get("confidence")
                    .and_then(serde_json::Value::as_f64)
                    .unwrap_or(0.0);
                co_changes.push((source_name.clone(), partner_name.to_string(), confidence));
            }
        }
    }

    if !co_changes.is_empty() {
        // Deduplicate symmetric pairs
        co_changes.sort_by(|a, b| b.2.partial_cmp(&a.2).unwrap_or(std::cmp::Ordering::Equal));
        co_changes.dedup_by(|a, b| (a.0 == b.0 && a.1 == b.1) || (a.0 == b.1 && a.1 == b.0));

        writeln!(out, "**Files that change together:**").unwrap();
        writeln!(out).unwrap();
        for (a, b, conf) in co_changes.iter().take(5) {
            writeln!(out, "- `{a}` + `{b}` (confidence: {conf:.0}%)").unwrap();
        }
        writeln!(out).unwrap();
    }

    Ok(())
}

// ── Danger Zones ──────────────────────────────────────────────────

async fn render_danger_zones(out: &mut String, store: &dyn HomerStore) -> crate::error::Result<()> {
    writeln!(out, "## Danger Zones").unwrap();
    writeln!(out).unwrap();
    writeln!(
        out,
        "Files with high change frequency and low bus factor require extra care."
    )
    .unwrap();
    writeln!(out).unwrap();

    let bus_results = store
        .get_analyses_by_kind(AnalysisKind::ContributorConcentration)
        .await?;
    let freq_results = store
        .get_analyses_by_kind(AnalysisKind::ChangeFrequency)
        .await?;

    // Build frequency map
    let freq_map: HashMap<_, _> = freq_results
        .iter()
        .filter_map(|r| Some((r.node_id, r.data.get("total")?.as_u64()?)))
        .collect();

    // Find files with bus_factor <= 1 and high change count
    let mut danger_files = Vec::new();
    for result in &bus_results {
        let bf = result
            .data
            .get("bus_factor")
            .and_then(serde_json::Value::as_u64)
            .unwrap_or(0);
        let total = freq_map.get(&result.node_id).copied().unwrap_or(0);

        if bf <= 1 && total >= 3 {
            let name = store
                .get_node(result.node_id)
                .await?
                .map_or_else(|| format!("node:{}", result.node_id.0), |n| n.name);
            let top_share = result
                .data
                .get("top_contributor_share")
                .and_then(serde_json::Value::as_f64)
                .unwrap_or(0.0);
            danger_files.push((name, total, bf, top_share));
        }
    }

    if danger_files.is_empty() {
        writeln!(out, "*No danger zones detected.*").unwrap();
        writeln!(out).unwrap();
        return Ok(());
    }

    danger_files.sort_by(|a, b| b.1.cmp(&a.1));

    writeln!(out, "| File | Changes | Bus Factor | Top Contributor |").unwrap();
    writeln!(out, "|------|--------:|-----------:|----------------:|").unwrap();

    for (name, total, bf, top_share) in danger_files.iter().take(10) {
        writeln!(
            out,
            "| `{name}` | {total} | {bf} | {:.0}% |",
            top_share * 100.0
        )
        .unwrap();
    }
    writeln!(out).unwrap();

    Ok(())
}

// ── Conventions ───────────────────────────────────────────────────

async fn render_conventions(out: &mut String, store: &dyn HomerStore) -> crate::error::Result<()> {
    writeln!(out, "## Conventions").unwrap();
    writeln!(out).unwrap();

    // Detect language distribution
    let file_filter = crate::types::NodeFilter {
        kind: Some(NodeKind::File),
        ..Default::default()
    };
    let files = store.find_nodes(&file_filter).await?;

    let mut lang_counts: HashMap<String, u32> = HashMap::new();
    for file in &files {
        if let Some(lang) = file.metadata.get("language").and_then(|v| v.as_str()) {
            *lang_counts.entry(lang.to_string()).or_default() += 1;
        }
    }

    if !lang_counts.is_empty() {
        let mut sorted: Vec<_> = lang_counts.iter().collect();
        sorted.sort_by(|a, b| b.1.cmp(a.1));

        writeln!(out, "**Languages:**").unwrap();
        for (lang, count) in &sorted {
            writeln!(out, "- {lang}: {count} files").unwrap();
        }
        writeln!(out).unwrap();
    }

    // Detect dependency counts
    let dep_filter = crate::types::NodeFilter {
        kind: Some(NodeKind::ExternalDep),
        ..Default::default()
    };
    let deps = store.find_nodes(&dep_filter).await?;
    if !deps.is_empty() {
        writeln!(out, "**Dependencies:** {} external packages", deps.len()).unwrap();
        writeln!(out).unwrap();
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::analyze::behavioral::BehavioralAnalyzer;
    use crate::analyze::traits::Analyzer;
    use crate::store::sqlite::SqliteStore;
    use crate::types::{Hyperedge, HyperedgeId, HyperedgeMember, Node, NodeId};
    use chrono::Utc;

    #[allow(clippy::too_many_lines)]
    async fn setup_full_dataset(store: &SqliteStore) {
        // Create file nodes
        let file_a = store
            .upsert_node(&Node {
                id: NodeId(0),
                kind: NodeKind::File,
                name: "src/main.rs".to_string(),
                content_hash: None,
                last_extracted: Utc::now(),
                metadata: {
                    let mut m = HashMap::new();
                    m.insert("language".to_string(), serde_json::json!("rust"));
                    m
                },
            })
            .await
            .unwrap();

        let file_b = store
            .upsert_node(&Node {
                id: NodeId(0),
                kind: NodeKind::File,
                name: "src/lib.rs".to_string(),
                content_hash: None,
                last_extracted: Utc::now(),
                metadata: {
                    let mut m = HashMap::new();
                    m.insert("language".to_string(), serde_json::json!("rust"));
                    m
                },
            })
            .await
            .unwrap();

        // Create module
        let root_mod = store
            .upsert_node(&Node {
                id: NodeId(0),
                kind: NodeKind::Module,
                name: ".".to_string(),
                content_hash: None,
                last_extracted: Utc::now(),
                metadata: HashMap::new(),
            })
            .await
            .unwrap();

        let src_mod = store
            .upsert_node(&Node {
                id: NodeId(0),
                kind: NodeKind::Module,
                name: "src".to_string(),
                content_hash: None,
                last_extracted: Utc::now(),
                metadata: HashMap::new(),
            })
            .await
            .unwrap();

        // BelongsTo edges
        for file_id in [file_a, file_b] {
            store
                .upsert_hyperedge(&Hyperedge {
                    id: HyperedgeId(0),
                    kind: HyperedgeKind::BelongsTo,
                    members: vec![
                        HyperedgeMember {
                            node_id: file_id,
                            role: "member".to_string(),
                            position: 0,
                        },
                        HyperedgeMember {
                            node_id: src_mod,
                            role: "container".to_string(),
                            position: 1,
                        },
                    ],
                    confidence: 1.0,
                    last_updated: Utc::now(),
                    metadata: HashMap::new(),
                })
                .await
                .unwrap();
        }

        // Function nodes
        store
            .upsert_node(&Node {
                id: NodeId(0),
                kind: NodeKind::Function,
                name: "src/main.rs::main".to_string(),
                content_hash: None,
                last_extracted: Utc::now(),
                metadata: {
                    let mut m = HashMap::new();
                    m.insert("file".to_string(), serde_json::json!("src/main.rs"));
                    m
                },
            })
            .await
            .unwrap();

        // Add build_systems metadata to root module for build detection
        if let Some(mut root) = store.get_node(root_mod).await.unwrap() {
            root.metadata
                .insert("build_systems".to_string(), serde_json::json!(["cargo"]));
            store.upsert_node(&root).await.unwrap();
        }

        // External dep
        store
            .upsert_node(&Node {
                id: NodeId(0),
                kind: NodeKind::ExternalDep,
                name: "serde".to_string(),
                content_hash: None,
                last_extracted: Utc::now(),
                metadata: HashMap::new(),
            })
            .await
            .unwrap();

        // Create commits + Modifies/Authored for behavioral analysis
        let author = store
            .upsert_node(&Node {
                id: NodeId(0),
                kind: NodeKind::Contributor,
                name: "dev@test.com".to_string(),
                content_hash: None,
                last_extracted: Utc::now(),
                metadata: HashMap::new(),
            })
            .await
            .unwrap();

        let now = Utc::now();
        for i in 0..4 {
            let commit = store
                .upsert_node(&Node {
                    id: NodeId(0),
                    kind: NodeKind::Commit,
                    name: format!("sha-{i}"),
                    content_hash: None,
                    last_extracted: now,
                    metadata: HashMap::new(),
                })
                .await
                .unwrap();

            store
                .upsert_hyperedge(&Hyperedge {
                    id: HyperedgeId(0),
                    kind: HyperedgeKind::Authored,
                    members: vec![
                        HyperedgeMember {
                            node_id: author,
                            role: "author".to_string(),
                            position: 0,
                        },
                        HyperedgeMember {
                            node_id: commit,
                            role: "commit".to_string(),
                            position: 1,
                        },
                    ],
                    confidence: 1.0,
                    last_updated: now - chrono::Duration::days(i * 7),
                    metadata: HashMap::new(),
                })
                .await
                .unwrap();

            let mut meta = HashMap::new();
            meta.insert(
                "files".to_string(),
                serde_json::json!([
                    {"path": "src/main.rs", "status": "modified", "lines_added": 5, "lines_deleted": 2},
                    {"path": "src/lib.rs", "status": "modified", "lines_added": 3, "lines_deleted": 1},
                ]),
            );

            store
                .upsert_hyperedge(&Hyperedge {
                    id: HyperedgeId(0),
                    kind: HyperedgeKind::Modifies,
                    members: vec![
                        HyperedgeMember {
                            node_id: commit,
                            role: "commit".to_string(),
                            position: 0,
                        },
                        HyperedgeMember {
                            node_id: file_a,
                            role: "file".to_string(),
                            position: 1,
                        },
                        HyperedgeMember {
                            node_id: file_b,
                            role: "file".to_string(),
                            position: 2,
                        },
                    ],
                    confidence: 1.0,
                    last_updated: now - chrono::Duration::days(i * 7),
                    metadata: meta,
                })
                .await
                .unwrap();
        }
    }

    #[tokio::test]
    async fn render_agents_md() {
        let store = SqliteStore::in_memory().unwrap();
        setup_full_dataset(&store).await;

        // Run behavioral analysis first
        let config = HomerConfig::default();
        let analyzer = BehavioralAnalyzer;
        analyzer.analyze(&store, &config).await.unwrap();

        // Now render
        let renderer = AgentsMdRenderer;
        let content = renderer.render(&store, &config).await.unwrap();

        assert!(content.contains("# AGENTS.md"), "Should have title");
        assert!(
            content.contains("## Build & Test Commands"),
            "Should have build section"
        );
        assert!(
            content.contains("cargo build"),
            "Should detect Cargo project"
        );
        assert!(content.contains("## Module Map"), "Should have module map");
        assert!(
            content.contains("## Change Patterns"),
            "Should have change patterns"
        );
        assert!(
            content.contains("src/main.rs"),
            "Should mention main.rs in changes"
        );
        assert!(
            content.contains("## Danger Zones"),
            "Should have danger zones"
        );
        assert!(
            content.contains("## Conventions"),
            "Should have conventions"
        );
        assert!(content.contains("rust"), "Should detect Rust language");
        assert!(
            content.contains("1 external packages"),
            "Should show dependency count"
        );
    }
}
